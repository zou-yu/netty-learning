#Netty Note
## IO 模型
### 同步阻塞 IO
发起读（写）请求一直到就绪的时间，线程会挂起阻塞，且读写的过程是同步的，不能干其他事情。

由于阻塞的时候线程没办法干其它事情，所以采用这种模型的服务器通常会为每个连接都起一个线程，这就导致了一旦客户端和服务器没有通讯需求时候，会导致线程资源浪费。

### 同步非阻塞 IO
发起读（写）请求后，如果资源没有就绪，就会立刻返回。值得注意的是就绪之后进行 IO 的过程依然是同步，线程必须挂起等待不能干其它事情。

### IO 多路复用
前面提到，如果资源没有就绪，读写请求会立刻返回，这意味着线程可以干其他事情了。

IO 多路复用就是利用这个原理（IO 多路复用也是同步非阻塞 IO 的一种），使用一个线程监听多个连接，不停轮询，直到这数个连接有 IO 事件发生了才进行处理。

Java NIO 就是使用的 IO 多路复用模型。 Redis 使用的 Linux 的 epoll 也是多路复用的实现，才能做到单线程的高效率。

### 信号驱动 IO
发起读（写）请求后，立刻返回。如果资源就绪后，由操作系统通知应用可以进行资源读写。这也是同步非阻塞 IO 的一种。

### 异步 IO
发起读（写）请求后，立刻返回（所以这是非阻塞的）。资源就绪后，由操作系统将数据从内核空间和用户空间之间传递（代为IO）。

JDK7 在 nio 包中新增了异步 IO 的功能。